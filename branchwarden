#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'TXT'
branchwarden - git branch hygiene CLI

Usage:
  branchwarden <subcommand> [flags]

Subcommands:
  status   Audit branch health (merged, gone upstream, ahead/behind)
  stale    List branches with no commits for N days
  clean    Delete safe branches (merged/gone) with dry-run by default
  audit    Detect GitHub branch-protection drift vs desired policy

Run 'branchwarden <subcommand> --help' for details.
TXT
}

status_help() {
  cat <<'TXT'
Usage: branchwarden status [--base <ref>] [--preset strict|balanced|solo-dev] [--protect <pattern>] [--config <path>]

Flags:
  --base <ref>       base branch to test merge status against (default: origin/main)
  --preset <name>    protected-branch preset: strict|balanced|solo-dev (default: balanced)
  --protect <pat>    additional protected branch pattern (repeatable; supports *)
  --config <path>    config file path (default: ./branchwarden.config)
TXT
}

stale_help() {
  cat <<'TXT'
Usage: branchwarden stale [--days <n>] [--preset strict|balanced|solo-dev] [--protect <pattern>] [--config <path>]

Flags:
  --days <n>         minimum age in days since last commit (default: 30)
  --preset <name>    protected-branch preset: strict|balanced|solo-dev (default: balanced)
  --protect <pat>    additional protected branch pattern (repeatable; supports *)
  --config <path>    config file path (default: ./branchwarden.config)
TXT
}

clean_help() {
  cat <<'TXT'
Usage: branchwarden clean [--base <ref>] [--mode merged|gone|both] [--yes] [--plan text|json] [--preset strict|balanced|solo-dev] [--protect <pattern>] [--config <path>]

Flags:
  --base <ref>             base branch to test merge status against (default: origin/main)
  --mode merged|gone|both  what to delete (default: both)
  --yes                    perform deletion (default is dry-run)
  --plan text|json         dry-run planner output format (default: text)
  --preset <name>          protected-branch preset: strict|balanced|solo-dev (default: balanced)
  --protect <pat>          additional protected branch pattern (repeatable; supports *)
  --config <path>          config file path (default: ./branchwarden.config)
TXT
}

audit_help() {
  cat <<'TXT'
Usage: branchwarden audit [--repo <owner/name>] [--base <branch>] [--config <path>]

Flags:
  --repo <owner/name>   GitHub repo (auto-detected from origin remote if omitted)
  --base <branch>       branch to audit protection for (default: main)
  --config <path>       config file path (default: ./branchwarden.config)

Config keys for policy:
  REQUIRED_CHECKS=<check name>[,<check name>...]
  REQUIRED_APPROVALS=<n>
  REQUIRE_CONVERSATION_RESOLUTION=true|false
  ENFORCE_ADMINS=true|false
TXT
}

ensure_git_repo() {
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "error: not inside a git repository" >&2
    exit 1
  fi
}

# config defaults
CFG_BASE=""
CFG_DAYS=""
CFG_MODE=""
CFG_PRESET=""
CFG_PROTECT=()
CFG_REQUIRED_CHECKS=""
CFG_REQUIRED_APPROVALS=""
CFG_REQUIRE_CONVERSATION_RESOLUTION=""
CFG_ENFORCE_ADMINS=""

trim() {
  local s="$1"
  s="${s#${s%%[![:space:]]*}}"
  s="${s%${s##*[![:space:]]}}"
  printf '%s' "$s"
}

append_csv_to_array() {
  local csv="$1"
  local -n ref_arr="$2"
  local IFS=','
  read -ra parts <<<"$csv"
  local p
  for p in "${parts[@]}"; do
    p="$(trim "$p")"
    [[ -n "$p" ]] && ref_arr+=("$p")
  done
}

load_config_file() {
  local path="$1"
  [[ -f "$path" ]] || return 0

  while IFS= read -r line; do
    line="$(trim "$line")"
    [[ -z "$line" || "$line" == \#* ]] && continue
    [[ "$line" == *=* ]] || continue

    local key="${line%%=*}"
    local val="${line#*=}"
    key="$(trim "$key")"
    val="$(trim "$val")"

    case "$key" in
      BASE) CFG_BASE="$val" ;;
      DAYS) CFG_DAYS="$val" ;;
      MODE) CFG_MODE="$val" ;;
      PRESET) CFG_PRESET="$val" ;;
      PROTECT) append_csv_to_array "$val" CFG_PROTECT ;;
      REQUIRED_CHECKS) CFG_REQUIRED_CHECKS="$val" ;;
      REQUIRED_APPROVALS) CFG_REQUIRED_APPROVALS="$val" ;;
      REQUIRE_CONVERSATION_RESOLUTION) CFG_REQUIRE_CONVERSATION_RESOLUTION="$val" ;;
      ENFORCE_ADMINS) CFG_ENFORCE_ADMINS="$val" ;;
    esac
  done <"$path"
}

preset_patterns() {
  local preset="$1"
  case "$preset" in
    strict)
      printf '%s\n' main master develop dev 'release/*' 'hotfix/*'
      ;;
    balanced)
      printf '%s\n' main master develop dev
      ;;
    solo-dev)
      printf '%s\n' main
      ;;
    *)
      echo "error: --preset must be one of: strict, balanced, solo-dev" >&2
      exit 1
      ;;
  esac
}

branch_is_protected() {
  local name="$1"
  shift || true
  local pat
  for pat in "$@"; do
    [[ -z "$pat" ]] && continue
    case "$name" in
      $pat) return 0 ;;
    esac
  done
  return 1
}

branch_rows() {
  git for-each-ref --format='%(refname:short)|%(upstream:track)|%(committerdate:unix)' refs/heads
}

merged_branches() {
  local base="$1"
  git branch --format='%(refname:short)' --merged "$base"
}

cmd_status() {
  local base="origin/main"
  local preset="balanced"
  local config_path="branchwarden.config"
  local protect_patterns=()

  # pre-scan config path
  local i=1
  while (( i <= $# )); do
    local arg="${!i}"
    if [[ "$arg" == "--config" ]]; then
      ((i++))
      [[ $i -le $# ]] || { echo "error: --config requires a value" >&2; exit 1; }
      config_path="${!i}"
    fi
    ((i++))
  done

  load_config_file "$config_path"
  [[ -n "$CFG_BASE" ]] && base="$CFG_BASE"
  [[ -n "$CFG_PRESET" ]] && preset="$CFG_PRESET"
  protect_patterns+=("${CFG_PROTECT[@]}")

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --base)
        shift; [[ $# -gt 0 ]] || { echo "error: --base requires a value" >&2; exit 1; }
        base="$1"
        ;;
      --preset)
        shift; [[ $# -gt 0 ]] || { echo "error: --preset requires a value" >&2; exit 1; }
        preset="$1"
        ;;
      --protect)
        shift; [[ $# -gt 0 ]] || { echo "error: --protect requires a value" >&2; exit 1; }
        protect_patterns+=("$1")
        ;;
      --config)
        shift; [[ $# -gt 0 ]] || { echo "error: --config requires a value" >&2; exit 1; }
        ;;
      --help|-h)
        status_help; exit 0 ;;
      *)
        echo "error: unknown flag for status: $1" >&2
        status_help >&2
        exit 1
        ;;
    esac
    shift
  done

  [[ -n "$base" ]] || { echo "error: --base cannot be empty" >&2; exit 1; }

  mapfile -t preset_protect < <(preset_patterns "$preset")
  local protected=("${preset_protect[@]}" "${protect_patterns[@]}")

  local merged_set
  if ! merged_set="$(merged_branches "$base" 2>/tmp/branchwarden_status_err)"; then
    echo "error: could not evaluate merged branches against '$base': $(cat /tmp/branchwarden_status_err)" >&2
    exit 1
  fi

  local merged=0 gone=0 diverged=0
  echo "Branch status:"
  while IFS='|' read -r name track _unix; do
    [[ -n "$name" ]] || continue
    branch_is_protected "$name" "${protected[@]}" && continue

    local states=()
    if grep -Fxq "$name" <<<"$merged_set"; then
      states+=("merged")
      ((merged+=1))
    fi
    if [[ "$track" == *gone* ]]; then
      states+=("upstream-gone")
      ((gone+=1))
    fi

    local ahead=0 behind=0
    if [[ "$track" =~ ahead[[:space:]]+([0-9]+) ]]; then ahead="${BASH_REMATCH[1]}"; fi
    if [[ "$track" =~ behind[[:space:]]+([0-9]+) ]]; then behind="${BASH_REMATCH[1]}"; fi
    if (( ahead > 0 || behind > 0 )); then
      states+=("ahead:${ahead} behind:${behind}")
      ((diverged+=1))
    fi

    if (( ${#states[@]} > 0 )); then
      printf -- "- %-28s %s\n" "$name" "$(IFS=', '; echo "${states[*]}")"
    fi
  done < <(branch_rows)

  echo
  echo "Summary: merged=${merged} gone=${gone} diverged=${diverged}"
}

cmd_stale() {
  local days=30
  local preset="balanced"
  local config_path="branchwarden.config"
  local protect_patterns=()

  local i=1
  while (( i <= $# )); do
    local arg="${!i}"
    if [[ "$arg" == "--config" ]]; then
      ((i++)); [[ $i -le $# ]] || { echo "error: --config requires a value" >&2; exit 1; }
      config_path="${!i}"
    fi
    ((i++))
  done

  load_config_file "$config_path"
  [[ -n "$CFG_DAYS" ]] && days="$CFG_DAYS"
  [[ -n "$CFG_PRESET" ]] && preset="$CFG_PRESET"
  protect_patterns+=("${CFG_PROTECT[@]}")

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --days)
        shift; [[ $# -gt 0 ]] || { echo "error: --days requires a value" >&2; exit 1; }
        days="$1"
        ;;
      --preset)
        shift; [[ $# -gt 0 ]] || { echo "error: --preset requires a value" >&2; exit 1; }
        preset="$1"
        ;;
      --protect)
        shift; [[ $# -gt 0 ]] || { echo "error: --protect requires a value" >&2; exit 1; }
        protect_patterns+=("$1")
        ;;
      --config)
        shift; [[ $# -gt 0 ]] || { echo "error: --config requires a value" >&2; exit 1; }
        ;;
      --help|-h)
        stale_help; exit 0 ;;
      *)
        echo "error: unknown flag for stale: $1" >&2
        stale_help >&2
        exit 1
        ;;
    esac
    shift
  done

  [[ "$days" =~ ^[0-9]+$ ]] || { echo "error: --days must be a positive integer" >&2; exit 1; }
  (( days > 0 )) || { echo "error: --days must be > 0" >&2; exit 1; }

  mapfile -t preset_protect < <(preset_patterns "$preset")
  local protected=("${preset_protect[@]}" "${protect_patterns[@]}")

  local now cutoff
  now=$(date +%s)
  cutoff=$(( now - (days * 86400) ))

  local count=0
  echo "Stale branches (>${days} days):"
  while IFS='|' read -r name _track unix; do
    [[ -n "$name" ]] || continue
    branch_is_protected "$name" "${protected[@]}" && continue
    (( unix <= cutoff )) || continue
    local ts
    ts=$(date -u -d "@${unix}" +%F)
    printf -- "- %-28s last-commit=%s\n" "$name" "$ts"
    ((count+=1))
  done < <(branch_rows)

  echo "Total stale branches: ${count}"
}

cmd_clean() {
  local base="origin/main"
  local mode="both"
  local yes="false"
  local plan="text"
  local preset="balanced"
  local config_path="branchwarden.config"
  local protect_patterns=()

  local i=1
  while (( i <= $# )); do
    local arg="${!i}"
    if [[ "$arg" == "--config" ]]; then
      ((i++)); [[ $i -le $# ]] || { echo "error: --config requires a value" >&2; exit 1; }
      config_path="${!i}"
    fi
    ((i++))
  done

  load_config_file "$config_path"
  [[ -n "$CFG_BASE" ]] && base="$CFG_BASE"
  [[ -n "$CFG_MODE" ]] && mode="$CFG_MODE"
  [[ -n "$CFG_PRESET" ]] && preset="$CFG_PRESET"
  protect_patterns+=("${CFG_PROTECT[@]}")

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --base)
        shift; [[ $# -gt 0 ]] || { echo "error: --base requires a value" >&2; exit 1; }
        base="$1"
        ;;
      --mode)
        shift; [[ $# -gt 0 ]] || { echo "error: --mode requires a value" >&2; exit 1; }
        mode="$1"
        ;;
      --yes)
        yes="true"
        ;;
      --plan)
        shift; [[ $# -gt 0 ]] || { echo "error: --plan requires a value" >&2; exit 1; }
        plan="$1"
        ;;
      --preset)
        shift; [[ $# -gt 0 ]] || { echo "error: --preset requires a value" >&2; exit 1; }
        preset="$1"
        ;;
      --protect)
        shift; [[ $# -gt 0 ]] || { echo "error: --protect requires a value" >&2; exit 1; }
        protect_patterns+=("$1")
        ;;
      --config)
        shift; [[ $# -gt 0 ]] || { echo "error: --config requires a value" >&2; exit 1; }
        ;;
      --help|-h)
        clean_help; exit 0 ;;
      *)
        echo "error: unknown flag for clean: $1" >&2
        clean_help >&2
        exit 1
        ;;
    esac
    shift
  done

  [[ -n "$base" ]] || { echo "error: --base cannot be empty" >&2; exit 1; }
  case "$mode" in
    merged|gone|both) ;;
    *) echo "error: --mode must be one of: merged, gone, both" >&2; exit 1 ;;
  esac
  case "$plan" in
    text|json) ;;
    *) echo "error: --plan must be one of: text, json" >&2; exit 1 ;;
  esac

  mapfile -t preset_protect < <(preset_patterns "$preset")
  local protected=("${preset_protect[@]}" "${protect_patterns[@]}")

  local merged_set
  if ! merged_set="$(merged_branches "$base" 2>/tmp/branchwarden_clean_err)"; then
    echo "error: could not evaluate merged branches against '$base': $(cat /tmp/branchwarden_clean_err)" >&2
    exit 1
  fi

  local candidates=()
  while IFS='|' read -r name track _unix; do
    [[ -n "$name" ]] || continue
    branch_is_protected "$name" "${protected[@]}" && continue

    local should_delete="false"
    if [[ "$mode" == "merged" || "$mode" == "both" ]]; then
      grep -Fxq "$name" <<<"$merged_set" && should_delete="true"
    fi
    if [[ "$mode" == "gone" || "$mode" == "both" ]]; then
      [[ "$track" == *gone* ]] && should_delete="true"
    fi

    [[ "$should_delete" == "true" ]] && candidates+=("$name")
  done < <(branch_rows)

  if (( ${#candidates[@]} == 0 )); then
    echo "No branches matched cleanup criteria."
    return
  fi

  if [[ "$yes" != "true" ]]; then
    if [[ "$plan" == "json" ]]; then
      printf '{"dryRun":true,"mode":"%s","base":"%s","count":%d,"candidates":[' "$mode" "$base" "${#candidates[@]}"
      local idx
      for idx in "${!candidates[@]}"; do
        [[ "$idx" -gt 0 ]] && printf ','
        printf '"%s"' "${candidates[$idx]}"
      done
      printf ']}\n'
    else
      echo "Dry run. Pass --yes to delete these branches:"
      printf -- "- %s\n" "${candidates[@]}"
    fi
    return
  fi

  local b
  for b in "${candidates[@]}"; do
    git branch -D "$b" >/dev/null
    echo "Deleted ${b}"
  done
}

cmd_audit() {
  local repo=""
  local base="main"
  local config_path="branchwarden.config"

  local i=1
  while (( i <= $# )); do
    local arg="${!i}"
    if [[ "$arg" == "--config" ]]; then
      ((i++)); [[ $i -le $# ]] || { echo "error: --config requires a value" >&2; exit 1; }
      config_path="${!i}"
    fi
    ((i++))
  done

  load_config_file "$config_path"

  local required_checks="CI / test"
  local required_approvals="1"
  local require_conversation_resolution="true"
  local enforce_admins="true"

  [[ -n "$CFG_REQUIRED_CHECKS" ]] && required_checks="$CFG_REQUIRED_CHECKS"
  [[ -n "$CFG_REQUIRED_APPROVALS" ]] && required_approvals="$CFG_REQUIRED_APPROVALS"
  [[ -n "$CFG_REQUIRE_CONVERSATION_RESOLUTION" ]] && require_conversation_resolution="$CFG_REQUIRE_CONVERSATION_RESOLUTION"
  [[ -n "$CFG_ENFORCE_ADMINS" ]] && enforce_admins="$CFG_ENFORCE_ADMINS"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo)
        shift; [[ $# -gt 0 ]] || { echo "error: --repo requires a value" >&2; exit 1; }
        repo="$1"
        ;;
      --base)
        shift; [[ $# -gt 0 ]] || { echo "error: --base requires a value" >&2; exit 1; }
        base="$1"
        ;;
      --config)
        shift; [[ $# -gt 0 ]] || { echo "error: --config requires a value" >&2; exit 1; }
        ;;
      --help|-h)
        audit_help; exit 0 ;;
      *)
        echo "error: unknown flag for audit: $1" >&2
        audit_help >&2
        exit 1
        ;;
    esac
    shift
  done

  if [[ -z "$repo" ]]; then
    local remote_url
    remote_url="$(git remote get-url origin 2>/dev/null || true)"
    if [[ "$remote_url" =~ github.com[:/]([^/]+/[^/.]+)(\.git)?$ ]]; then
      repo="${BASH_REMATCH[1]}"
    else
      echo "error: unable to auto-detect GitHub repo from origin; pass --repo owner/name" >&2
      exit 1
    fi
  fi

  local protection_json
  if ! protection_json="$(gh api repos/${repo}/branches/${base}/protection 2>/tmp/branchwarden_audit_err)"; then
    echo "error: could not fetch branch protection for ${repo}:${base}: $(cat /tmp/branchwarden_audit_err)" >&2
    exit 1
  fi

  python3 - <<'PY' "$protection_json" "$required_checks" "$required_approvals" "$require_conversation_resolution" "$enforce_admins"
import json, sys
actual = json.loads(sys.argv[1])
want_checks = [c.strip() for c in sys.argv[2].split(',') if c.strip()]
want_approvals = int(sys.argv[3])
want_conv = sys.argv[4].lower() == 'true'
want_admins = sys.argv[5].lower() == 'true'

act_checks = sorted([(c.get('context') or '') for c in actual.get('required_status_checks', {}).get('checks', [])])
if not act_checks:
    act_checks = sorted(actual.get('required_status_checks', {}).get('contexts', []))

act_approvals = actual.get('required_pull_request_reviews', {}).get('required_approving_review_count', 0)
act_conv = actual.get('required_conversation_resolution', {}).get('enabled', False)
act_admins = actual.get('enforce_admins', {}).get('enabled', False)

drift = []
if sorted(want_checks) != act_checks:
    drift.append(f"required checks mismatch (want={want_checks}, got={act_checks})")
if want_approvals != act_approvals:
    drift.append(f"required approvals mismatch (want={want_approvals}, got={act_approvals})")
if want_conv != act_conv:
    drift.append(f"conversation resolution mismatch (want={want_conv}, got={act_conv})")
if want_admins != act_admins:
    drift.append(f"enforce admins mismatch (want={want_admins}, got={act_admins})")

if drift:
    print("DRIFT detected:")
    for line in drift:
      print(f"- {line}")
    sys.exit(2)

print("No drift: branch protection matches desired policy.")
PY
}

main() {
  if [[ $# -lt 1 ]]; then
    usage
    exit 2
  fi

  local sub="$1"; shift
  case "$sub" in
    help|-h|--help)
      usage
      ;;
    status)
      ensure_git_repo
      cmd_status "$@"
      ;;
    stale)
      ensure_git_repo
      cmd_stale "$@"
      ;;
    clean)
      ensure_git_repo
      cmd_clean "$@"
      ;;
    audit)
      ensure_git_repo
      cmd_audit "$@"
      ;;
    *)
      echo "error: unknown subcommand '$sub'" >&2
      usage >&2
      exit 1
      ;;
  esac
}

main "$@"
