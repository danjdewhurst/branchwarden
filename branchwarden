#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'TXT'
branchwarden - git branch hygiene CLI

Usage:
  branchwarden <subcommand> [flags]

Subcommands:
  status   Audit branch health (merged, gone upstream, ahead/behind)
  stale    List branches with no commits for N days
  clean    Delete safe branches (merged/gone) with dry-run by default
  audit    Detect GitHub branch-protection drift vs desired policy
  apply    Apply desired branch-protection policy (use --fix to enforce)
  bulk     Run audit/apply across org repos filtered by topic/pattern

Run 'branchwarden <subcommand> --help' for details.
TXT
}

apply_help() {
  cat <<'TXT'
Usage: branchwarden apply [--repo <owner/name>] [--base <branch>] [--fix] [--config <path>]

Flags:
  --repo <owner/name>   GitHub repo (auto-detected from origin remote if omitted)
  --base <branch>       branch to enforce protection for (default: main)
  --fix                 apply changes via GitHub API (default: drift preview only)
                        (updates classic branch protection and bootstraps ruleset when missing)
  --config <path>       config file path (default: ./branchwarden.config)
TXT
}

bulk_help() {
  cat <<'TXT'
Usage: branchwarden bulk --org <org> [--topic <topic>] [--pattern <regex>] [--action audit|apply] [--base <branch>] [--fix]

Flags:
  --org <org>           GitHub org to scan
  --topic <topic>       required repo topic (repeatable)
  --pattern <regex>     regex against repo name (default: .*)
  --action <mode>       audit or apply (default: audit)
  --base <branch>       branch (default: main)
  --fix                 when --action apply, enforce changes
TXT
}

status_help() {
  cat <<'TXT'
Usage: branchwarden status [--base <ref>] [--preset strict|balanced|solo-dev] [--protect <pattern>] [--config <path>]

Flags:
  --base <ref>       base branch to test merge status against (default: origin/main)
  --preset <name>    protected-branch preset: strict|balanced|solo-dev (default: balanced)
  --protect <pat>    additional protected branch pattern (repeatable; supports *)
  --config <path>    config file path (default: ./branchwarden.config)
TXT
}

stale_help() {
  cat <<'TXT'
Usage: branchwarden stale [--days <n>] [--preset strict|balanced|solo-dev] [--protect <pattern>] [--config <path>]

Flags:
  --days <n>         minimum age in days since last commit (default: 30)
  --preset <name>    protected-branch preset: strict|balanced|solo-dev (default: balanced)
  --protect <pat>    additional protected branch pattern (repeatable; supports *)
  --config <path>    config file path (default: ./branchwarden.config)
TXT
}

clean_help() {
  cat <<'TXT'
Usage: branchwarden clean [--base <ref>] [--mode merged|gone|both] [--yes] [--plan text|json] [--preset strict|balanced|solo-dev] [--protect <pattern>] [--config <path>]

Flags:
  --base <ref>             base branch to test merge status against (default: origin/main)
  --mode merged|gone|both  what to delete (default: both)
  --yes                    perform deletion (default is dry-run)
  --plan text|json         dry-run planner output format (default: text)
  --preset <name>          protected-branch preset: strict|balanced|solo-dev (default: balanced)
  --protect <pat>          additional protected branch pattern (repeatable; supports *)
  --config <path>          config file path (default: ./branchwarden.config)
TXT
}

audit_help() {
  cat <<'TXT'
Usage: branchwarden audit [--repo <owner/name>] [--base <branch>] [--config <path>]

Flags:
  --repo <owner/name>   GitHub repo (auto-detected from origin remote if omitted)
  --base <branch>       branch to audit protection for (default: main)
  --config <path>       config file path (default: ./branchwarden.config)

Config keys for policy:
  REQUIRED_CHECKS=<check name>[,<check name>...]
  REQUIRED_APPROVALS=<n>
  REQUIRE_CONVERSATION_RESOLUTION=true|false
  ENFORCE_ADMINS=true|false
TXT
}

ensure_git_repo() {
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "error: not inside a git repository" >&2
    exit 1
  fi
}

# config defaults
CFG_BASE=""
CFG_DAYS=""
CFG_MODE=""
CFG_PRESET=""
CFG_PROTECT=()
CFG_REQUIRED_CHECKS=""
CFG_REQUIRED_APPROVALS=""
CFG_REQUIRE_CONVERSATION_RESOLUTION=""
CFG_ENFORCE_ADMINS=""

trim() {
  local s="$1"
  s="${s#${s%%[![:space:]]*}}"
  s="${s%${s##*[![:space:]]}}"
  printf '%s' "$s"
}

append_csv_to_array() {
  local csv="$1"
  local -n ref_arr="$2"
  local IFS=','
  read -ra parts <<<"$csv"
  local p
  for p in "${parts[@]}"; do
    p="$(trim "$p")"
    [[ -n "$p" ]] && ref_arr+=("$p")
  done
}

load_config_file() {
  local path="$1"
  [[ -f "$path" ]] || return 0

  while IFS= read -r line; do
    line="$(trim "$line")"
    [[ -z "$line" || "$line" == \#* ]] && continue
    [[ "$line" == *=* ]] || continue

    local key="${line%%=*}"
    local val="${line#*=}"
    key="$(trim "$key")"
    val="$(trim "$val")"

    case "$key" in
      BASE) CFG_BASE="$val" ;;
      DAYS) CFG_DAYS="$val" ;;
      MODE) CFG_MODE="$val" ;;
      PRESET) CFG_PRESET="$val" ;;
      PROTECT) append_csv_to_array "$val" CFG_PROTECT ;;
      REQUIRED_CHECKS) CFG_REQUIRED_CHECKS="$val" ;;
      REQUIRED_APPROVALS) CFG_REQUIRED_APPROVALS="$val" ;;
      REQUIRE_CONVERSATION_RESOLUTION) CFG_REQUIRE_CONVERSATION_RESOLUTION="$val" ;;
      ENFORCE_ADMINS) CFG_ENFORCE_ADMINS="$val" ;;
    esac
  done <"$path"
}

autodetect_repo() {
  local remote_url
  remote_url="$(git remote get-url origin 2>/dev/null || true)"
  if [[ "$remote_url" =~ github.com[:/]([^/]+/[^/.]+)(\.git)?$ ]]; then
    printf '%s\n' "${BASH_REMATCH[1]}"
    return 0
  fi
  return 1
}

fetch_matching_rulesets_count() {
  local repo="$1"
  local base="$2"
  local rs_json
  if ! rs_json="$(gh api "repos/${repo}/rulesets" --paginate 2>/dev/null || true)"; then
    echo "0"
    return 0
  fi

  python3 - <<'PY' "$rs_json" "$base"
import json, sys
rows = json.loads(sys.argv[1] or '[]')
base = sys.argv[2]
count = 0
for r in rows:
    if r.get('target') != 'branch':
        continue
    cond = (r.get('conditions') or {}).get('ref_name') or {}
    include = cond.get('include') or []
    pats = [str(x).split('/')[-1] for x in include]
    if '~DEFAULT_BRANCH' in include or base in pats or f'refs/heads/{base}' in include:
        count += 1
print(count)
PY
}

preset_patterns() {
  local preset="$1"
  case "$preset" in
    strict)
      printf '%s\n' main master develop dev 'release/*' 'hotfix/*'
      ;;
    balanced)
      printf '%s\n' main master develop dev
      ;;
    solo-dev)
      printf '%s\n' main
      ;;
    *)
      echo "error: --preset must be one of: strict, balanced, solo-dev" >&2
      exit 1
      ;;
  esac
}

branch_is_protected() {
  local name="$1"
  shift || true
  local pat
  for pat in "$@"; do
    [[ -z "$pat" ]] && continue
    case "$name" in
      $pat) return 0 ;;
    esac
  done
  return 1
}

branch_rows() {
  git for-each-ref --format='%(refname:short)|%(upstream:track)|%(committerdate:unix)' refs/heads
}

merged_branches() {
  local base="$1"
  git branch --format='%(refname:short)' --merged "$base"
}

cmd_status() {
  local base="origin/main"
  local preset="balanced"
  local config_path="branchwarden.config"
  local protect_patterns=()

  # pre-scan config path
  local i=1
  while (( i <= $# )); do
    local arg="${!i}"
    if [[ "$arg" == "--config" ]]; then
      ((i++))
      [[ $i -le $# ]] || { echo "error: --config requires a value" >&2; exit 1; }
      config_path="${!i}"
    fi
    ((i++))
  done

  load_config_file "$config_path"
  [[ -n "$CFG_BASE" ]] && base="$CFG_BASE"
  [[ -n "$CFG_PRESET" ]] && preset="$CFG_PRESET"
  protect_patterns+=("${CFG_PROTECT[@]}")

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --base)
        shift; [[ $# -gt 0 ]] || { echo "error: --base requires a value" >&2; exit 1; }
        base="$1"
        ;;
      --preset)
        shift; [[ $# -gt 0 ]] || { echo "error: --preset requires a value" >&2; exit 1; }
        preset="$1"
        ;;
      --protect)
        shift; [[ $# -gt 0 ]] || { echo "error: --protect requires a value" >&2; exit 1; }
        protect_patterns+=("$1")
        ;;
      --config)
        shift; [[ $# -gt 0 ]] || { echo "error: --config requires a value" >&2; exit 1; }
        ;;
      --help|-h)
        status_help; exit 0 ;;
      *)
        echo "error: unknown flag for status: $1" >&2
        status_help >&2
        exit 1
        ;;
    esac
    shift
  done

  [[ -n "$base" ]] || { echo "error: --base cannot be empty" >&2; exit 1; }

  mapfile -t preset_protect < <(preset_patterns "$preset")
  local protected=("${preset_protect[@]}" "${protect_patterns[@]}")

  local merged_set
  if ! merged_set="$(merged_branches "$base" 2>/tmp/branchwarden_status_err)"; then
    echo "error: could not evaluate merged branches against '$base': $(cat /tmp/branchwarden_status_err)" >&2
    exit 1
  fi

  local merged=0 gone=0 diverged=0
  echo "Branch status:"
  while IFS='|' read -r name track _unix; do
    [[ -n "$name" ]] || continue
    branch_is_protected "$name" "${protected[@]}" && continue

    local states=()
    if grep -Fxq "$name" <<<"$merged_set"; then
      states+=("merged")
      ((merged+=1))
    fi
    if [[ "$track" == *gone* ]]; then
      states+=("upstream-gone")
      ((gone+=1))
    fi

    local ahead=0 behind=0
    if [[ "$track" =~ ahead[[:space:]]+([0-9]+) ]]; then ahead="${BASH_REMATCH[1]}"; fi
    if [[ "$track" =~ behind[[:space:]]+([0-9]+) ]]; then behind="${BASH_REMATCH[1]}"; fi
    if (( ahead > 0 || behind > 0 )); then
      states+=("ahead:${ahead} behind:${behind}")
      ((diverged+=1))
    fi

    if (( ${#states[@]} > 0 )); then
      printf -- "- %-28s %s\n" "$name" "$(IFS=', '; echo "${states[*]}")"
    fi
  done < <(branch_rows)

  echo
  echo "Summary: merged=${merged} gone=${gone} diverged=${diverged}"
}

cmd_stale() {
  local days=30
  local preset="balanced"
  local config_path="branchwarden.config"
  local protect_patterns=()

  local i=1
  while (( i <= $# )); do
    local arg="${!i}"
    if [[ "$arg" == "--config" ]]; then
      ((i++)); [[ $i -le $# ]] || { echo "error: --config requires a value" >&2; exit 1; }
      config_path="${!i}"
    fi
    ((i++))
  done

  load_config_file "$config_path"
  [[ -n "$CFG_DAYS" ]] && days="$CFG_DAYS"
  [[ -n "$CFG_PRESET" ]] && preset="$CFG_PRESET"
  protect_patterns+=("${CFG_PROTECT[@]}")

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --days)
        shift; [[ $# -gt 0 ]] || { echo "error: --days requires a value" >&2; exit 1; }
        days="$1"
        ;;
      --preset)
        shift; [[ $# -gt 0 ]] || { echo "error: --preset requires a value" >&2; exit 1; }
        preset="$1"
        ;;
      --protect)
        shift; [[ $# -gt 0 ]] || { echo "error: --protect requires a value" >&2; exit 1; }
        protect_patterns+=("$1")
        ;;
      --config)
        shift; [[ $# -gt 0 ]] || { echo "error: --config requires a value" >&2; exit 1; }
        ;;
      --help|-h)
        stale_help; exit 0 ;;
      *)
        echo "error: unknown flag for stale: $1" >&2
        stale_help >&2
        exit 1
        ;;
    esac
    shift
  done

  [[ "$days" =~ ^[0-9]+$ ]] || { echo "error: --days must be a positive integer" >&2; exit 1; }
  (( days > 0 )) || { echo "error: --days must be > 0" >&2; exit 1; }

  mapfile -t preset_protect < <(preset_patterns "$preset")
  local protected=("${preset_protect[@]}" "${protect_patterns[@]}")

  local now cutoff
  now=$(date +%s)
  cutoff=$(( now - (days * 86400) ))

  local count=0
  echo "Stale branches (>${days} days):"
  while IFS='|' read -r name _track unix; do
    [[ -n "$name" ]] || continue
    branch_is_protected "$name" "${protected[@]}" && continue
    (( unix <= cutoff )) || continue
    local ts
    ts=$(date -u -d "@${unix}" +%F)
    printf -- "- %-28s last-commit=%s\n" "$name" "$ts"
    ((count+=1))
  done < <(branch_rows)

  echo "Total stale branches: ${count}"
}

cmd_clean() {
  local base="origin/main"
  local mode="both"
  local yes="false"
  local plan="text"
  local preset="balanced"
  local config_path="branchwarden.config"
  local protect_patterns=()

  local i=1
  while (( i <= $# )); do
    local arg="${!i}"
    if [[ "$arg" == "--config" ]]; then
      ((i++)); [[ $i -le $# ]] || { echo "error: --config requires a value" >&2; exit 1; }
      config_path="${!i}"
    fi
    ((i++))
  done

  load_config_file "$config_path"
  [[ -n "$CFG_BASE" ]] && base="$CFG_BASE"
  [[ -n "$CFG_MODE" ]] && mode="$CFG_MODE"
  [[ -n "$CFG_PRESET" ]] && preset="$CFG_PRESET"
  protect_patterns+=("${CFG_PROTECT[@]}")

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --base)
        shift; [[ $# -gt 0 ]] || { echo "error: --base requires a value" >&2; exit 1; }
        base="$1"
        ;;
      --mode)
        shift; [[ $# -gt 0 ]] || { echo "error: --mode requires a value" >&2; exit 1; }
        mode="$1"
        ;;
      --yes)
        yes="true"
        ;;
      --plan)
        shift; [[ $# -gt 0 ]] || { echo "error: --plan requires a value" >&2; exit 1; }
        plan="$1"
        ;;
      --preset)
        shift; [[ $# -gt 0 ]] || { echo "error: --preset requires a value" >&2; exit 1; }
        preset="$1"
        ;;
      --protect)
        shift; [[ $# -gt 0 ]] || { echo "error: --protect requires a value" >&2; exit 1; }
        protect_patterns+=("$1")
        ;;
      --config)
        shift; [[ $# -gt 0 ]] || { echo "error: --config requires a value" >&2; exit 1; }
        ;;
      --help|-h)
        clean_help; exit 0 ;;
      *)
        echo "error: unknown flag for clean: $1" >&2
        clean_help >&2
        exit 1
        ;;
    esac
    shift
  done

  [[ -n "$base" ]] || { echo "error: --base cannot be empty" >&2; exit 1; }
  case "$mode" in
    merged|gone|both) ;;
    *) echo "error: --mode must be one of: merged, gone, both" >&2; exit 1 ;;
  esac
  case "$plan" in
    text|json) ;;
    *) echo "error: --plan must be one of: text, json" >&2; exit 1 ;;
  esac

  mapfile -t preset_protect < <(preset_patterns "$preset")
  local protected=("${preset_protect[@]}" "${protect_patterns[@]}")

  local merged_set
  if ! merged_set="$(merged_branches "$base" 2>/tmp/branchwarden_clean_err)"; then
    echo "error: could not evaluate merged branches against '$base': $(cat /tmp/branchwarden_clean_err)" >&2
    exit 1
  fi

  local candidates=()
  while IFS='|' read -r name track _unix; do
    [[ -n "$name" ]] || continue
    branch_is_protected "$name" "${protected[@]}" && continue

    local should_delete="false"
    if [[ "$mode" == "merged" || "$mode" == "both" ]]; then
      grep -Fxq "$name" <<<"$merged_set" && should_delete="true"
    fi
    if [[ "$mode" == "gone" || "$mode" == "both" ]]; then
      [[ "$track" == *gone* ]] && should_delete="true"
    fi

    [[ "$should_delete" == "true" ]] && candidates+=("$name")
  done < <(branch_rows)

  if (( ${#candidates[@]} == 0 )); then
    echo "No branches matched cleanup criteria."
    return
  fi

  if [[ "$yes" != "true" ]]; then
    if [[ "$plan" == "json" ]]; then
      printf '{"dryRun":true,"mode":"%s","base":"%s","count":%d,"candidates":[' "$mode" "$base" "${#candidates[@]}"
      local idx
      for idx in "${!candidates[@]}"; do
        [[ "$idx" -gt 0 ]] && printf ','
        printf '"%s"' "${candidates[$idx]}"
      done
      printf ']}\n'
    else
      echo "Dry run. Pass --yes to delete these branches:"
      printf -- "- %s\n" "${candidates[@]}"
    fi
    return
  fi

  local b
  for b in "${candidates[@]}"; do
    git branch -D "$b" >/dev/null
    echo "Deleted ${b}"
  done
}

cmd_audit() {
  local repo=""
  local base="main"
  local config_path="branchwarden.config"

  local i=1
  while (( i <= $# )); do
    local arg="${!i}"
    if [[ "$arg" == "--config" ]]; then
      ((i++)); [[ $i -le $# ]] || { echo "error: --config requires a value" >&2; exit 1; }
      config_path="${!i}"
    fi
    ((i++))
  done

  load_config_file "$config_path"

  local required_checks="CI / test"
  local required_approvals="1"
  local require_conversation_resolution="true"
  local enforce_admins="true"

  [[ -n "$CFG_REQUIRED_CHECKS" ]] && required_checks="$CFG_REQUIRED_CHECKS"
  [[ -n "$CFG_REQUIRED_APPROVALS" ]] && required_approvals="$CFG_REQUIRED_APPROVALS"
  [[ -n "$CFG_REQUIRE_CONVERSATION_RESOLUTION" ]] && require_conversation_resolution="$CFG_REQUIRE_CONVERSATION_RESOLUTION"
  [[ -n "$CFG_ENFORCE_ADMINS" ]] && enforce_admins="$CFG_ENFORCE_ADMINS"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo)
        shift; [[ $# -gt 0 ]] || { echo "error: --repo requires a value" >&2; exit 1; }
        repo="$1"
        ;;
      --base)
        shift; [[ $# -gt 0 ]] || { echo "error: --base requires a value" >&2; exit 1; }
        base="$1"
        ;;
      --config)
        shift; [[ $# -gt 0 ]] || { echo "error: --config requires a value" >&2; exit 1; }
        ;;
      --help|-h)
        audit_help; exit 0 ;;
      *)
        echo "error: unknown flag for audit: $1" >&2
        audit_help >&2
        exit 1
        ;;
    esac
    shift
  done

  if [[ -z "$repo" ]]; then
    if ! repo="$(autodetect_repo)"; then
      echo "error: unable to auto-detect GitHub repo from origin; pass --repo owner/name" >&2
      exit 1
    fi
  fi

  local rulesets_count
  rulesets_count="$(fetch_matching_rulesets_count "$repo" "$base")"
  echo "Rulesets matching ${base}: ${rulesets_count}"

  local protection_json
  if ! protection_json="$(gh api repos/${repo}/branches/${base}/protection 2>/tmp/branchwarden_audit_err)"; then
    echo "error: could not fetch branch protection for ${repo}:${base}: $(cat /tmp/branchwarden_audit_err)" >&2
    exit 1
  fi

  python3 - <<'PY' "$protection_json" "$required_checks" "$required_approvals" "$require_conversation_resolution" "$enforce_admins"
import json, sys
actual = json.loads(sys.argv[1])
want_checks = [c.strip() for c in sys.argv[2].split(',') if c.strip()]
want_approvals = int(sys.argv[3])
want_conv = sys.argv[4].lower() == 'true'
want_admins = sys.argv[5].lower() == 'true'

act_checks = sorted([(c.get('context') or '') for c in actual.get('required_status_checks', {}).get('checks', [])])
if not act_checks:
    act_checks = sorted(actual.get('required_status_checks', {}).get('contexts', []))

act_approvals = actual.get('required_pull_request_reviews', {}).get('required_approving_review_count', 0)
act_conv = actual.get('required_conversation_resolution', {}).get('enabled', False)
act_admins = actual.get('enforce_admins', {}).get('enabled', False)

drift = []
if sorted(want_checks) != act_checks:
    drift.append(f"required checks mismatch (want={want_checks}, got={act_checks})")
if want_approvals != act_approvals:
    drift.append(f"required approvals mismatch (want={want_approvals}, got={act_approvals})")
if want_conv != act_conv:
    drift.append(f"conversation resolution mismatch (want={want_conv}, got={act_conv})")
if want_admins != act_admins:
    drift.append(f"enforce admins mismatch (want={want_admins}, got={act_admins})")

if drift:
    print("DRIFT detected:")
    for line in drift:
      print(f"- {line}")
    sys.exit(2)

print("No drift: branch protection matches desired policy.")
PY
}

cmd_apply() {
  local repo=""
  local base="main"
  local do_fix="false"
  local config_path="branchwarden.config"

  local i=1
  while (( i <= $# )); do
    local arg="${!i}"
    if [[ "$arg" == "--config" ]]; then
      ((i++)); [[ $i -le $# ]] || { echo "error: --config requires a value" >&2; exit 1; }
      config_path="${!i}"
    fi
    ((i++))
  done

  load_config_file "$config_path"

  local required_checks="CI / test"
  local required_approvals="1"
  local require_conversation_resolution="true"
  local enforce_admins="true"

  [[ -n "$CFG_REQUIRED_CHECKS" ]] && required_checks="$CFG_REQUIRED_CHECKS"
  [[ -n "$CFG_REQUIRED_APPROVALS" ]] && required_approvals="$CFG_REQUIRED_APPROVALS"
  [[ -n "$CFG_REQUIRE_CONVERSATION_RESOLUTION" ]] && require_conversation_resolution="$CFG_REQUIRE_CONVERSATION_RESOLUTION"
  [[ -n "$CFG_ENFORCE_ADMINS" ]] && enforce_admins="$CFG_ENFORCE_ADMINS"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --repo)
        shift; [[ $# -gt 0 ]] || { echo "error: --repo requires a value" >&2; exit 1; }
        repo="$1"
        ;;
      --base)
        shift; [[ $# -gt 0 ]] || { echo "error: --base requires a value" >&2; exit 1; }
        base="$1"
        ;;
      --fix)
        do_fix="true"
        ;;
      --config)
        shift; [[ $# -gt 0 ]] || { echo "error: --config requires a value" >&2; exit 1; }
        ;;
      --help|-h)
        apply_help; exit 0 ;;
      *)
        echo "error: unknown flag for apply: $1" >&2
        apply_help >&2
        exit 1
        ;;
    esac
    shift
  done

  if [[ -z "$repo" ]]; then
    if ! repo="$(autodetect_repo)"; then
      echo "error: unable to auto-detect GitHub repo from origin; pass --repo owner/name" >&2
      exit 1
    fi
  fi

  local rulesets_count
  rulesets_count="$(fetch_matching_rulesets_count "$repo" "$base")"

  local protection_json
  if ! protection_json="$(gh api repos/${repo}/branches/${base}/protection 2>/tmp/branchwarden_apply_err)"; then
    echo "error: could not fetch branch protection for ${repo}:${base}: $(cat /tmp/branchwarden_apply_err)" >&2
    exit 1
  fi

  local payload_file
  payload_file="$(mktemp)"
  local drift_rc=0
  set +e
  python3 - <<'PY' "$protection_json" "$required_checks" "$required_approvals" "$require_conversation_resolution" "$enforce_admins" "$payload_file"
import json, sys
actual = json.loads(sys.argv[1])
want_checks = [c.strip() for c in sys.argv[2].split(',') if c.strip()]
want_approvals = int(sys.argv[3])
want_conv = sys.argv[4].lower() == 'true'
want_admins = sys.argv[5].lower() == 'true'
payload_file = sys.argv[6]

act_checks = sorted([(c.get('context') or '') for c in actual.get('required_status_checks', {}).get('checks', [])])
if not act_checks:
    act_checks = sorted(actual.get('required_status_checks', {}).get('contexts', []))
act_approvals = actual.get('required_pull_request_reviews', {}).get('required_approving_review_count', 0)
act_conv = actual.get('required_conversation_resolution', {}).get('enabled', False)
act_admins = actual.get('enforce_admins', {}).get('enabled', False)

drift = []
if sorted(want_checks) != act_checks:
    drift.append(f"required checks mismatch (want={want_checks}, got={act_checks})")
if want_approvals != act_approvals:
    drift.append(f"required approvals mismatch (want={want_approvals}, got={act_approvals})")
if want_conv != act_conv:
    drift.append(f"conversation resolution mismatch (want={want_conv}, got={act_conv})")
if want_admins != act_admins:
    drift.append(f"enforce admins mismatch (want={want_admins}, got={act_admins})")

payload = {
  "required_status_checks": {"strict": True, "checks": [{"context": c} for c in want_checks]},
  "enforce_admins": want_admins,
  "required_pull_request_reviews": {
    "dismiss_stale_reviews": True,
    "require_code_owner_reviews": False,
    "required_approving_review_count": want_approvals,
    "require_last_push_approval": False
  },
  "restrictions": None,
  "required_conversation_resolution": want_conv
}
with open(payload_file, 'w', encoding='utf-8') as f:
    json.dump(payload, f)

if drift:
    print("DRIFT detected:")
    for line in drift:
        print(f"- {line}")
    sys.exit(2)

print("No drift: branch protection already matches desired policy.")
PY
  drift_rc=$?
  set -e

  if [[ "$drift_rc" -eq 0 ]]; then
    rm -f "$payload_file"
    return
  fi

  if [[ "$do_fix" != "true" ]]; then
    echo "Preview only. Re-run with --fix to apply this policy."
    rm -f "$payload_file"
    exit 2
  fi

  gh api -X PUT "repos/${repo}/branches/${base}/protection" --input "$payload_file" >/dev/null
  rm -f "$payload_file"

  if [[ "$rulesets_count" == "0" ]]; then
    local rs_payload
    rs_payload="$(mktemp)"
    python3 - <<'PY' "$base" "$required_checks" "$required_approvals" >"$rs_payload"
import json, sys
base = sys.argv[1]
checks = [c.strip() for c in sys.argv[2].split(',') if c.strip()]
approvals = int(sys.argv[3])
payload = {
  "name": f"branchwarden-{base}",
  "target": "branch",
  "enforcement": "active",
  "conditions": {"ref_name": {"include": [f"refs/heads/{base}"], "exclude": []}},
  "rules": [
    {"type": "pull_request", "parameters": {"required_approving_review_count": approvals}},
    {"type": "required_status_checks", "parameters": {"required_status_checks": [{"context": c} for c in checks], "strict_required_status_checks_policy": True}}
  ]
}
print(json.dumps(payload))
PY
    gh api -X POST "repos/${repo}/rulesets" --input "$rs_payload" >/dev/null || true
    rm -f "$rs_payload"
    echo "Created baseline repository ruleset for ${base}"
  fi

  echo "Applied policy to ${repo}:${base} (rulesets matching branch: ${rulesets_count})"
}

cmd_bulk() {
  local org=""
  local pattern=".*"
  local action="audit"
  local base="main"
  local do_fix="false"
  local topics=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --org) shift; org="$1" ;;
      --topic) shift; topics+=("$1") ;;
      --pattern) shift; pattern="$1" ;;
      --action) shift; action="$1" ;;
      --base) shift; base="$1" ;;
      --fix) do_fix="true" ;;
      --help|-h) bulk_help; exit 0 ;;
      *) echo "error: unknown flag for bulk: $1" >&2; bulk_help >&2; exit 1 ;;
    esac
    shift
  done

  [[ -n "$org" ]] || { echo "error: --org is required" >&2; exit 1; }
  [[ "$action" == "audit" || "$action" == "apply" ]] || { echo "error: --action must be audit|apply" >&2; exit 1; }

  local repos_json
  repos_json="$(gh api "orgs/${org}/repos" --paginate)"
  local repo_lines
  repo_lines="$(python3 - <<'PY' "$repos_json" "$pattern" "${topics[*]}"
import json, re, sys
rows = json.loads(sys.argv[1])
pattern = re.compile(sys.argv[2])
topics = [t for t in sys.argv[3].split() if t]
for r in rows:
    name = r.get('name','')
    if not pattern.search(name):
        continue
    rt = set(r.get('topics') or [])
    if topics and any(t not in rt for t in topics):
        continue
    print(r.get('full_name'))
PY
)"

  [[ -n "$repo_lines" ]] || { echo "No repos matched filters."; return; }
  while IFS= read -r repo; do
    [[ -z "$repo" ]] && continue
    echo "==> ${repo}"
    if [[ "$action" == "audit" ]]; then
      "$0" audit --repo "$repo" --base "$base" || true
    else
      if [[ "$do_fix" == "true" ]]; then
        "$0" apply --repo "$repo" --base "$base" --fix || true
      else
        "$0" apply --repo "$repo" --base "$base" || true
      fi
    fi
  done <<<"$repo_lines"
}

main() {
  if [[ $# -lt 1 ]]; then
    usage
    exit 2
  fi

  local sub="$1"; shift
  case "$sub" in
    help|-h|--help)
      usage
      ;;
    status)
      ensure_git_repo
      cmd_status "$@"
      ;;
    stale)
      ensure_git_repo
      cmd_stale "$@"
      ;;
    clean)
      ensure_git_repo
      cmd_clean "$@"
      ;;
    audit)
      ensure_git_repo
      cmd_audit "$@"
      ;;
    apply)
      ensure_git_repo
      cmd_apply "$@"
      ;;
    bulk)
      cmd_bulk "$@"
      ;;
    *)
      echo "error: unknown subcommand '$sub'" >&2
      usage >&2
      exit 1
      ;;
  esac
}

main "$@"
